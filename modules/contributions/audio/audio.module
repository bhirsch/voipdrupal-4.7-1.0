<?php
// $Id: audio.module,v 1.51.2.23 2006/09/05 23:18:53 drewish Exp $

include(drupal_get_path('module', 'audio') .'/audio.theme');
if (module_exist('views')) {
  include(drupal_get_path('module', 'audio') .'/views_audio.inc');
}

/**
 * Implementation of hook_help
 */
function audio_help($section) {
  switch ($section) {
    case 'audio/by':
      return t("You can browse for audio by any of the following fields.");
    case 'admin/help#audio':
      $help  = '<p>'. t('The audio module allows users to upload and store audio files on a Drupal site. Audio is an important medium for community communication as the recent rise of the <a href="%elink-en-wikipedia-org">podcast phenomenon</a> demonstrates.', array('%elink-en-wikipedia-org' => 'http://en.wikipedia.org/wiki/Podcasting')) .'</p>';
      $help .= '<p>'. t('Users create audio nodes by uploading a file from their computer. They are then able to make changes to the metadata, perhaps adding an artist, or removing the track number. Visitors can download the audio file, view the file\'s metadata and encoding information, or browse for audio by metadata (artist, title, year, etc). Visitors can even play MP3s within their browser using the <a href="%elink-musicplayer-sourceforge-net">XSPF flash player</a> that is bundled with the module.', array('%elink-musicplayer-sourceforge-net' => 'http://musicplayer.sourceforge.net/')) .'</p>';
      $help .= '<p>'. t('The module uses the <a href="%elink-www-getid3-org">getID3 library</a> to read and write <a href="%elink-en-wikipedia-org">ID3 tag</a> information from the audio file. getID3 can read metadata from a many different audio and video formats giving the audio module a great deal of flexibility.', array('%elink-www-getid3-org' => 'http://www.getid3.org', '%elink-en-wikipedia-org' => 'http://en.wikipedia.org/wiki/Id3')) .'</p>';
      $help .= t('<p>You can:</p>
                    <ul>
                    <li>add an audio file at <a href="%node-add-audio">create content &gt;&gt; audio</a>.</li>
                    <li>see your most recent audio files at <a href="%user">user account</a>.</li>
                    <li>see all of the most recently added audio files at <a href="%audio">audio</a>.</li>
                    <li>browse for audio by its metadata (artist, album, genre, etc) at <a href="%audio-by">audio &gt;&gt; by</a>.</li>
                    <li>enable the <em>latest audio</em>, <em>random audio</em>, and <em>browse for audio</em> blocks at <a href="%admin-block">administer &gt;&gt; block</a>.</li>
                    <li>administer audio module at <a href="%admin-settings-audio">administers &gt;&gt; settings &gt;&gt; audio</a>.</li>
                    <li>download and the <em>required</em> getID3 library from <a href="%elink-prdownloads-sourceforge-net">getID3 sourceforge</a> page.</li>
                    </ul>', array('%audio' => url('audio'), '%audio-by' => url('audio/by'), '%user' => url('user'), '%node-add-audio' => url('node/add/audio'), '%admin-block' => url('admin/block'), '%admin-settings-audio' => url('admin/settings/audio'), '%elink-prdownloads-sourceforge-net' => 'http://prdownloads.sourceforge.net/getid3'));
      $help .= '<p>'. t('For more information please read the configuration and customization handbook <a href="%audio">Audio page</a>.', array('%audio' => 'http://www.drupal.org/handbook/modules/audio/')) .'</p>';
      return $help;
    case 'admin/modules#description':
      return t('Allows uploading and playback of audio files. ');
    case 'admin/settings/audio':
      $help = '<p><b>'. t('The current PHP configuration limits file uploads to %maxsize', array('%maxsize' => format_size(audio_get_max_upload_size()))) .'</b><br />';
      $help .= '<p>'. t("There are two PHP ini settings, upload_max_filesize and post_max_size, that limit the maximum size of uploads. You can change these settings in the php.ini file or by using a php_value directive in Apache .htaccess file. Consult the PHP documentation for more info.") . '</p>';
      return $help;
    case 'admin/settings/audio/metadata':
      $help = t("These settings let you determine what metadata the audio module tracks. You can add or remove metadata tags and select how they will be used.
        <ul>
        <li><em>autocomplete</em> enables javacript autocompletion of the tag based on existing values.</li>
        <li><em>required</em> forces a user to enter a value</li>
        <li><em>hidden</em> prevents the tag from being listed in the node view</li>
        <li><em>browsable</em> allows users to browse for audio using that tag</li>
        <li><em>written to file</em> indicates that the tag should be saved to the file (this requires getid3 support)</li>
        <li><em>weight</em> determines the order of the tags, lower weights are listed first</li>
        <li><em>delete</em> indicates that you would like to remove the tag from the allowed list</li>
        </ul>");
      $help .= '<p>'. t('<strong>Note:</strong> deleting a tag will not remove it from the database or file until the node is saved again.') .'</p>';
      return $help;
    case 'node/add#audio':
      return t('An audio file. The audio file could be used for adding music, podcasts, or audio clips to your site.');
  }
}

/**
 * Implementation of hook_menu
 *
 * adds the following paths:
 *
 * audio                - displays all audio files
 * audio/by             - allows browsing by meta data
 * audio/play/{nid}     - plays the audio file (link to file in browser)
 * audio/download/{nid} - forces browser (hopefully) to download the audio file
 * audio/feed           - feed of latest audio
 * audio/feed/user/{uid}- feed of a user's audio
 * audio/user/{iud}     - displays audio files from user uid
 * node/add/audio       - adds an audio node
 */
function audio_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/audio/main', 'title' => t('audio'),
      'callback' => 'audio_settings',
      'access' => user_access('administer site configuration'),
      'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => '-10');
    $items[] = array(
      'path' => 'admin/settings/audio/metadata', 'title' => t('metadata tags'),
      'callback' => 'audio_admin_settings_metadata',
      'access' => user_access('administer site configuration'),
      'type' => MENU_LOCAL_TASK, 'weight' => '-1');

    $items[] = array(
      'path' => 'audio', 'title' => t('audio'),
      'access' => user_access('access content'),
      'type' => MENU_NORMAL_ITEM,
      'callback' => 'audio_page');
    $items[] = array(
      'path' => 'audio/autocomplete',
      'title' => t('autocomplete metedata'),
      'callback' => 'audio_autocomplete',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'audio/by', 'title' => t('browse by'),
      'access' => user_access('access content'),
      'type' => MENU_NORMAL_ITEM,
      'callback' => 'audio_page_browse_by');
    $items[] = array(
      'path' => 'audio/user', 'title' => t("user's audio files"),
      'access' => user_access('access content'),
      'type' => MENU_SUGGESTED_ITEM,
      'callback' => 'audio_page_user');

    $items[] = array(
      'path' => 'audio/feed', 'title' => t('audio feed'),
      'access' => user_access('access content'),
      'type' => MENU_SUGGESTED_ITEM,
      'callback' => 'audio_feed_latest');
    $items[] = array(
      'path' => 'audio/feed/user', 'title' => t("users's audio feed"),
      'access' => user_access('access content'),
      'type' => MENU_SUGGESTED_ITEM,
      'callback' => 'audio_feed_user');

    $items[] = array(
      'path' => 'audio/download', 'title' => t('download'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
      'callback' => 'audio_download');
    $items[] = array(
      'path' => 'audio/play', 'title' => t('play'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
      'callback' => 'audio_play');

    $items[] = array(
      'path' => 'node/add/audio', 'title' => t('audio'),
      'access' => user_access('create audio'),
      'type' => MENU_NORMAL_ITEM);
  }
  return $items;
}

/**
 * Implementation of hook_node_info
 */
function audio_node_info() {
  return array('audio' => array('name' => t('audio'), 'base' => 'audio'));
}

/**
 * Invoke hook_audio api methods.
 *
 * The audio module provide a hook for contributed modules. Use this rather than
 * the nodeapi so you don't have to worry about the module invocation order.
 *
 *   function hook_audio($op, $node, $arg1)
 *
 * @param $op
 *   The $op value will be one of the following:
 *   'load'
 *       An audio node is being loaded.
 *   'prepare'
 *       A node form/preview is being built.
 *   'insert'
 *       A new audio node is being created. Changes you make to the node's
 *       audio_images, audio_file, and audio_fileinfo memebers will be saved.
 *   'insert revision'
 *       A new revision of an audio node is being created. Changes you make to
 *       the node's audio_images, audio_file, and audio_fileinfo memebers will
 *       be saved.
 *   'update'
 *       Changes to an audio node are being saved. Changes you make to the
 *       node's audio_images, audio_file, and audio_fileinfo memebers will be
 *       saved.
 *   'delete'
 *       An audio node is being deleted. Remove all of the nodes files and
 *       database records.
 *   'delete revision'
 *       A revision of the audio node is being deleted. Remove any version
 *       specific files or database records.
 *   'upload'
 *       A new audio file has been uploaded. Contrib modules can read data from
 *       the file and append it to the audio node at this point.
 *   'access'
 *       An operation is being performed on the node and other modules can
 *       determine if this will be allowed. $arg1 will describe the operation
 *       (i.e. 'play' or 'download'). Return a boolean if you want to allow or
 *       deny this, or NULL if you don't.
 *   'download'
 *       A user is playing the audio node. This can be handy if you're recording
 *       user statistics.
 *   'play'
 *       A user is downloading an audio node. This can be handy if you're
 *       recording user statistics.
 * @param $node
 *   An audio node object.
 */
function audio_invoke_audioapi($op, &$node, $a3 = NULL, $a4 = NULL) {
  $return = array();
  foreach (module_implements('audio') as $name) {
    $function = $name .'_audio';
    $result = $function($op, $node, $a3, $a4);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Implementation of hook_perm
 */
function audio_perm() {
  return array('administer audio', 'create audio', 'edit own audio',
    'play audio', 'download audio', 'view download stats');
}

/**
 * Implementation of hook_access
 */
function audio_access($op, $node = null) {
  global $user;

  // admins can do whatever they like
  if (user_access('administer audio')) {
    return TRUE;
  }

  if ($op == 'update' || $op == 'delete') {
    if (($user->uid == $node->uid) && user_access('edit own audio')) {
      return TRUE;
    }
  }
  if ($op == 'create') {
    if (user_access('create audio')) {
      return TRUE;
    }
  }
}

/**
 * Is the current user allowed to download an audio node?
 *
 * @return
 *   boolean indicating if it's allowed
 */
function _audio_allow_download($node) {
  if (isset($node->url_download) && $node->audio_fileinfo['downloadable']) {
    // let other modules affect the download permissions
    $result = audio_invoke_audioapi('access', $node, 'download');
    if (in_array(TRUE, $result)) {
      return TRUE;
    }
    if (in_array(FALSE, $result)) {
      return FALSE;
    }
    return user_access('download audio');
  }
  return FALSE;
}

/**
 * Is the current user allowed to play an audio node?
 *
 * @return
 *   boolean indicating if it's allowed
 */
function _audio_allow_play($node) {
  if (isset($node->url_play)) {
    // let other modules affect the download permissions
    $result = audio_invoke_audioapi('access', $node, 'play');
    if (in_array(TRUE, $result)) {
      return TRUE;
    }
    if (in_array(FALSE, $result)) {
      return FALSE;
    }
    return user_access('play audio');
  }
  return FALSE;
}


/**
 * Build a title for the node.
 *
 * @param $node
 *   node object with title_format and audio_tags values.
 * @return
 *   node object with a title set
 */
function audio_set_title($node) {
  // make sure there's a title format
  if (!isset($node->title_format)) {
    $node->title_format = variable_get('audio_default_title_format', '%title by %artist');
  }
  // make sure that all the allowed tags are included.
  foreach (audio_get_tags_allowed() as $tag) {
    $params['%'. $tag] = isset($node->audio_tags[$tag]) ? $node->audio_tags[$tag] : '';
  }
  // build the title
  $node->title = t($node->title_format, (array)$params);

  return $node;
}


/**
 * Implementation of hook_link.
 */
function audio_link($type, $node, $main = 0) {
  $links = array();
  $link_access = user_access('view download stats');

  if ($type == 'node' && $node->type == 'audio') {
    if (_audio_allow_download($node)) {
      $links[] = l(t('download audio file'), $node->url_download, NULL);
      if($link_access){
        $links[] = t('%download_count downloads', array('%download_count' => $node->audio_fileinfo['download_count']));
      }
    }
    if (_audio_allow_play($node) && $link_access) {
      $links[] = t('%play_count plays', array('%play_count' => $node->audio_fileinfo['play_count']));
    }
  }

  return $links;
}

/**
 * Implementation of hook_nodeapi().
 */
function audio_nodeapi(&$node, $op, $arg) {
  if ($node->type == 'audio') {
    switch ($op) {
      case 'delete revision':
        audio_delete_revision($node);
        break;

      case 'rss item':
        $ret = array();
        if (_audio_allow_download($node)) {
          // NOTE: we'll try to reset the node's body to remove theming, this only
          // works with this patch: http://drupal.org/node/41703
          $body = db_result(db_query("SELECT r.body FROM {node} n INNER JOIN {node_revisions} r ON n.nid = r.nid WHERE n.vid=%d", $node->vid));
          $node->body = $body;
          $node->teaser = $body;

          // package up the feed info
          $ret[] = array(
            'key' => 'enclosure',
            'attributes' => array(
              'url' => $node->url_download,
              'length' => $node->audio_file->filesize,
              'type' => $node->audio_file->filemime
            ));
          // really basic itunes support
          $ret[] = array(
            'namespace' => array(
              'itunes' => 'xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"'
            ));
          $ret[] = array(
            'key' => 'itunes:duration',
            'value' => $node->audio_fileinfo['playtime']);
          $ret[] = array(
            'key' => 'itunes:author',
            'value' => $node->audio_tags['artist']);
        }
        return $ret;

      case 'update index':
        // in case the user's changed the theme to hide tag values, return an
        // array of all the tag values for the search index.
        $cleantags = array();
        foreach ($node->audio_tags as $value) {
          $cleantags[] = check_plain($value);
        }
        return $cleantags;
    }
  }
}

/**
 * Implementation of hook_view
 */
function audio_view(&$node, $teaser = FALSE, $page = FALSE) {
  theme_add_style(drupal_get_path('module','audio') .'/audio.css');
  $node = audio_set_title($node);
  $node = node_prepare($node, $teaser);
  $node->teaser = theme('audio_teaser', $node);
  $node->body = theme('audio_display', $node);
}

/**
 * Implementation of hook_validate. Called after load and when editing.
 */
function audio_validate(&$node) {
  // check if the fid was stored in the session when audio_prepare() was called.
  // make sure we've got an fid and file
  if (!isset($node->audio_file) && !isset($_SESSION['audio_file'])) {
    form_set_error('audio_upload', t("A file must be provided. If you tried uploading a file, make sure it's less than the upload size limit."));
  }
}

/**
 * Implementation of hook_load
 */
function audio_load($node) {
  $ret = array();

  if ($node->vid) {
    // load the audio records...
    $ret['audio_fileinfo'] = db_fetch_array(db_query("SELECT * FROM {audio} WHERE vid=%d", $node->vid));
    // ... then move some non-file info stuff out of the array
    $ret['title_format'] = $ret['audio_fileinfo']['title_format'];
    unset($ret['audio_fileinfo']['title_format']);

    // load the file
    $result = db_query('SELECT origname, filename, filepath, filemime, filesize FROM {audio_file} f WHERE f.vid = %d', $node->vid);
    $ret['audio_file'] = $file = db_fetch_object($result);
    $ret['audio_fileinfo']['filesize'] = $file->filesize;

    if (file_exists($file->filepath)) {
      // TODO: should these links be by vid?
      $ret['url_play'] = url('audio/play/'. $node->nid, NULL, NULL, TRUE);
      if ($ret['audio_fileinfo']['downloadable']) {
        // iTunes and other podcasting programs check the url to determine the
        // file type. we'll add the original file name on to the end. see issues
        // #35398 and #68716 for more info.
        $url = 'audio/download/'. $node->nid .'/'. $file->origname;
        $ret['url_download'] = url($url , NULL, NULL, TRUE);
      }
    }

    // load the audio tags
    $result = db_query("SELECT tag, value FROM {audio_metadata} WHERE vid=%d", $node->vid);
    $ret['audio_tags'] = $params = array();
    while ($obj = db_fetch_object($result)) {
      $ret['audio_tags'][$obj->tag] = $obj->value;
      $params['%'. $obj->tag] = $obj->value;
    }

    // allow other modules to access newly loaded audio node
    $ret = array_merge($ret, audio_invoke_audioapi('load', $node));
  }

  return $ret;
}

/**
 * Implementation of hook_insert
 */
function audio_insert(&$node) {
  $directory = audio_get_directory();

  // the original filename is preserved in the name field so we can avoid name
  // collisions but restore the original name when they download it.
  $node->audio_file->origname = $node->audio_file->filename;
  // unset the new file flag so we don't run into problems if the same node
  // object is saved
  unset($node->audio_file->newfile);

  // move the file to the audio directory...
  // TODO: better error checking that the move works...
  file_move($node->audio_file, $directory, FILE_EXISTS_RENAME);

  // notify other modules
  audio_invoke_audioapi('insert', $node);

  // add the file record
  $f = $node->audio_file;
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, $f->filename, $f->filepath, $f->filemime, filesize($f->filepath));

  // add the audio record
  $i = $node->audio_fileinfo;
  db_query("INSERT INTO {audio} (vid, nid, title_format, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);

  // add the tags records
  _audio_save_tags_to_db($node);
}

/**
 * Insert a new node revision. If a new file wasn't uploaded, make a copy of the
 * existing file.
 */
function audio_insert_revision($node) {
  $directory = audio_get_directory();

  // new file uploaded?
  if (isset($node->audio_file->newfile)) {
    // the original filename is preserved in the name field so we can avoid name
    // collisions but restore the original name when they download it.
    $node->audio_file->origname = $node->audio_file->filename;

    // move the new file to the audio directory...
    // TODO: better error checking that the move worked...
    file_move($node->audio_file, $directory, FILE_EXISTS_RENAME);
  }
  else {
    // copy the existing file (use the original name)
    $newname = file_create_filename($node->audio_file->origname, $directory);
    // TODO: better error checking that the copy worked...
    file_copy($node->audio_file, $newname);
  }

  // notify other modules
  audio_invoke_audioapi('insert revision', $node);

  // add the file record
  $f = $node->audio_file;
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, $f->filename, $f->filepath, $f->filemime, filesize($f->filepath));

  // add the audio record
  $i = $node->audio_fileinfo;
  db_query("INSERT INTO {audio} (vid, nid, title_format, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);

  // add the tags records
  _audio_save_tags_to_db($node);
}

/**
 * Implementation of hook_update
 */
function audio_update(&$node) {
  // check for new revsion
  if ($node->revision) {
    return audio_insert_revision($node);
  }

  $directory = audio_get_directory();

  // new file uploaded?
  if (isset($node->audio_file->newfile)) {
    unset($node->audio_file->newfile);

    // remove the old file
    $oldfile = db_fetch_object(db_query('SELECT filepath FROM {audio_file} f WHERE f.vid = %d', $node->vid));
    file_delete($oldfile->filepath);

    // save the new one
    // TODO: better error checking that the move works...
    file_move($node->audio_file, $directory, FILE_EXISTS_RENAME);
  }

  // notify other modules
  audio_invoke_audioapi('update', $node);

  // do a delete and insert rather than an update to ensure that we've got db
  // records. it takes a bit longer but it allows us to carry on if one of the
  // records wasn't created by audio_insert().
  db_query("DELETE FROM {audio} WHERE vid=%d", $node->vid);
  db_query("DELETE FROM {audio_file} WHERE vid=%d", $node->vid);
  $i = $node->audio_fileinfo;
  db_query("INSERT INTO {audio} (vid, nid, title_format, play_count, download_count, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, %d, %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['play_count'], $i['download_count'], $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);
  $f = $node->audio_file;
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, $f->filename, $f->filepath, $f->filemime, filesize($f->filepath));

  // add the tags records
  _audio_save_tags_to_db($node);
}

/**
 * Implementation of hook_delete.
 */
function audio_delete($node) {
  // notify other modules
  audio_invoke_audioapi('delete', $node);

  $result = db_query('SELECT vid FROM {audio} WHERE nid = %d', $node->nid);
  while ($o = db_fetch_object($result)) {
    if ($filepath = db_result(db_query('SELECT filepath FROM {audio_file} WHERE vid = %d', $o->vid))) {
      file_delete($filepath);
    }
    db_query('DELETE FROM {audio_metadata} WHERE vid = %d', $o->vid);
    db_query('DELETE FROM {audio_file} WHERE vid = %d', $o->vid);
  }
  db_query('DELETE FROM {audio} WHERE nid = %d', $node->nid);
}

/**
 * Delete a single revision.
 */
function audio_delete_revision($node) {
  // notify other modules
  audio_invoke_audioapi('delete revision', $node);

  if ($filepath = db_result(db_query('SELECT filepath FROM {audio_file} WHERE vid = %d', $node->vid))) {
    file_delete($filepath);
  }

  db_query('DELETE FROM {audio_metadata} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {audio_file} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {audio} WHERE vid = %d', $node->vid);
}

/**
 * Implementation of hook_prepare. We do a lot here because we need to read
 * the file's meta data after upload but before both the form and node preview
 * are built.
 */
function audio_prepare(&$node) {
  // Clears our files in session when you enter the edit view the first time.
  // This is so files don't linger on the form if you happen to leave the node
  // and come back into it.
  if(count($_POST) == 0) {
    if (isset($_SESSION['audio_file']) && count($_SESSION['audio_file'])) {
      // TODO: check that this actually deletes unsaved temp files
      foreach((array)$_SESSION['audio_file'] as $file) {
        file_delete($file->filepath);
      }
    }
    unset($_SESSION['audio_file']);
  }

  // check for an upload
  if ($file = file_check_upload('audio_upload')) {
    // save the upload into drupal's temp directory
    $temppath = file_directory_temp() . '/audio/';
    file_check_directory($temppath, TRUE);

    $node->audio_file = file_save_upload($file, $temppath .'/'. $file->filename, FILE_EXISTS_REPLACE);
    $node->audio_file->origname = $file->filename;
    $node->audio_file->newfile = TRUE;

    $node->audio_fileinfo = array(
      'play_count' => 0,
      'download_count' => 0,
      'filesize' => filesize($node->audio_file->filepath),
      'downloadable' => $_POST['edit']['audio_fileinfo']['downloadable'],
    );

    // allow other modules to modify the node
    audio_invoke_audioapi('upload', $node);

    // ...save info to $_POST so that it shows up in both the preview and form.
    $_POST['edit']['audio_fileinfo'] = $node->audio_fileinfo;
    $_POST['edit']['audio_tags'] = $node->audio_tags;

    $_SESSION['audio_file'] = $node->audio_file;
  }
  else if (!empty($_SESSION['audio_file'])) {
    $node->audio_file = $_SESSION['audio_file'];
  }
  else {
    $_SESSION['audio_file'] = $node->audio_file;
  }

  audio_invoke_audioapi('prepare', $node);
}

/**
 * Implementation of hook_form
 */
function audio_form(&$node, &$param) {
  // make sure the node has a title format
  if (!isset($node->title_format)) {
    $node->title_format = variable_get('audio_default_title_format', '%title by %artist');
  }

  $form['#attributes'] = array('enctype' => 'multipart/form-data');

  // sometimes folks want to hide the ugly title and unneeded body fields. for now, not worth the clutter on the settings page.
  if (variable_get('audio_show_form_title', TRUE)) {
    $form['title_format'] = array(
      '#type' => 'textfield', '#title' => t('Title'),
      '#default_value' => $node->title_format,
      '#description' => t("The title can use the file's metadata. Depending on what's filled out, you maybe able to use any of the following variables: " ) . '%artist, %album, %title, %track, %genre, %year',
      '#required' => TRUE,
      '#weight' => -5,
    );

    $form['body_filter']['#weight'] = -4;
    $form['body_filter']['body'] = array(
      '#type' => 'textarea',
      '#title' => t('Body'),
      '#default_value' => $node->body,
      '#rows' => 5,
      '#required' => FALSE,
      );
    $form['body_filter']['format'] = filter_form($node->format);
  }

  $form['audio_fileinfo'] = array(
    '#type' => 'fieldset', '#title' => t('Audio File Info'),
    '#collapsible'=> TRUE,
    '#weight' => -1,
    '#tree' => TRUE,
    '#theme' => 'audio_fileinfo_form',
  );
  $form['audio_fileinfo']['filepath'] = array(
    '#type' => 'item', '#title' => t('Current File'),
    '#value' => t('No file is attached.'),
    '#weight' => -1,
  );
  $form['audio_fileinfo']['audio_upload'] = array(
    '#tree' => FALSE, // this is so we can nest the control and still leave the upload where check_upload expects it
    '#type' => 'file', '#title' => t('Add a new audio file'),
    '#description' => t('Click "Browse..." to select an audio file to upload. <strong>NOTE:</strong> the current PHP configuration limits uploads to %maxsize. ', array('%maxsize' => format_size(audio_get_max_upload_size()))),
    '#weight' => 19,
  );
  $form['audio_fileinfo']['downloadable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow file downloads.'),
    '#return_value' => 1,
    '#default_value' => isset($node->audio_fileinfo['downloadable']) ? $node->audio_fileinfo['downloadable'] : variable_get('audio_default_downloadable', 1),
    '#description' => t('If checked, a link will be displayed allowing visitors to download this audio file on to their own computer.')
      . t('<strong>WARNING:</strong> even if you leave this unchecked, clever users will be able to find a way to download the file. This just makes them work a little harder to find the link.'),
    '#weight' => 20,
  );


  // if we've got a file add the fields for editing meta data and displaying
  // the file's info
  if (isset($node->audio_file)) {
    $form['audio_tags'] = array(
      '#type' => 'fieldset', '#title' => t('Audio Metadata'),
      '#collapsible'=> TRUE,
      '#tree' => TRUE,
      '#weight' => -3,
    );
    // we delegate out the dirty work of building form elements
    foreach (audio_get_tag_settings() as $tag => $tag_settings) {
      $form['audio_tags'][$tag] = _audio_build_tag_form($tag, $tag_settings, $node->audio_tags[$tag]);
    }

    // file info
    $form['audio_fileinfo']['filepath']['#value'] = $node->audio_file->filepath;
    $form['audio_fileinfo']['audio_upload']['#title'] = t('Replace this with a new file');
    $form['audio_fileinfo']['play_count'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['play_count']);
    $form['audio_fileinfo']['download_count'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['download_count']);
    $form['audio_fileinfo']['fileformat'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['fileformat']);
    $form['audio_fileinfo']['filesize'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['filesize']);
    $form['audio_fileinfo']['playtime'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['playtime']);
    $form['audio_fileinfo']['sample_rate'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['sample_rate']);
    $form['audio_fileinfo']['channel_mode'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['channel_mode']);
    $form['audio_fileinfo']['bitrate'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['bitrate']);
    $form['audio_fileinfo']['bitrate_mode'] = array(
      '#type' => 'value', '#value' => $node->audio_fileinfo['bitrate_mode']);
  }

  return $form;
}

/**
 * Construct a form element to represent a tag
 *
 * @param $tag
 *   name of the tag
 * @param $tag_settings
 *   array of settings that determine the way the tag is handled.
 * @param $value
 *   value of the tag
 * @return
 *  Array with a form element
 */
function _audio_build_tag_form($tag, $tag_settings, $value) {
  switch ($tag) {
    case 'track':
      $ret = array(
        '#type' => 'textfield', '#title' => t('Track Number'), '#maxlength' => 10,
        '#description' => t("Enter either a single number or fraction here. '1' means that this is the first track on the album, and '1/8' ."),
      );
      break;
    case 'genre':
      $ret = array('#type' => 'textfield', '#title' => t('Genre'), '#maxlength' => 40);
      break;
    default:
      $ret = array('#type' => 'textfield', '#title' => t(ucwords(str_replace('_', ' ', $tag))), '#maxlength' => 255);
      break;
  }

  if ($tag_settings['autocomplete']) {
    $ret['#autocomplete_path'] = 'audio/autocomplete/'. $tag;
  }
  $ret['#required'] = (boolean) $tag_settings['required'];
  $ret['#default_value'] = $value;

  return $ret;
}


function audio_submit(&$node) {
  // check if the file was stored in the session during audio_prepare().
  if (isset($_SESSION['audio_file'])) {
    $node->audio_file = $_SESSION['audio_file'];
    // won't be needing this any longer
    unset($_SESSION['audio_file']);
  }

  // build the title
  $node = audio_set_title($node);
}


/**
 * Implementation of hook_user().
 */
function audio_user($op, &$edit, &$user, $category = NULL) {
  if ($op == 'view') {
    $result = db_query(db_rewrite_sql("SELECT COUNT(*) FROM {node} n WHERE n.type = 'audio' AND n.uid = %d AND n.status = 1"), $user->uid);
    if (db_result($result) > 0) {
      $items[] = array('title' => t('Audio'),
        'value' => l(t("listen to %username's recent audio files", array('%username' => $user->name)), 'audio/user/'. $user->uid, array('title' => t("Read %username's latest blog entries.", array('%username' => $user->name)))),
        'class' => 'blog',
      );
      return array(t('History') => $items);
    }
  }
}

/**
 * Implementation of hook_block.
 *
 * Offers 2 blocks: latest audio and random audio
 */
function audio_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks[0]['info'] = t('audio: Latest');
      $blocks[1]['info'] = t('audio: Random');
      $blocks[2]['info'] = t('audio: Browse by');
      return $blocks;

    case 'configure':
      $options = array(1 => '1', 2 => '2', 3 => '3',  4 => '4', 5 => '5', 6 => '6', 7 => '7',  8 => '8', 9 => '9', 10 => '10', 15 => '15', 20 => '20', 25 => '25', 30 => '30');
      $form = array();
      switch($delta) {
        case 0:
          $form['audio_block_latest_n'] = array(
            '#type' => 'select',
            '#title' => t('Show <em>n</em> recent audio nodes'),
            '#default_value' => variable_get('review_n_latest', 1),
            '#options' => $options,
            '#description' => t('The block will show this many of the most recent audio nodes.')
          );
          break;
        case 1:
          $form['audio_block_random_n'] = array(
            '#type' => 'select',
            '#title' => t('Show <em>n</em> random audio nodes'),
            '#default_value' => variable_get('review_n_latest', 1),
            '#options' => $options,
            '#description' => t('The block will show this many random audio nodes.')
          );
          break;
      }
      return $form;

    case 'save':
      switch($delta) {
        case 0:
          variable_set('audio_block_latest_n', $edit['audio_block_latest_n']);
          break;
        case 1:
          variable_set('audio_block_random_n', $edit['audio_block_random_n']);
          break;
      }
      break;

    case 'view':
      if (user_access('access content')) {
        switch($delta) {
          case 0:
            $audio = audio_get_latest(variable_get('audio_block_latest_n', 1));
            $block['subject'] = t('Latest audio');
            $block['content'] = theme('audio_block', $audio);
            break;
          case 1:
            $audio = audio_get_random(variable_get('audio_block_random_n', 1));
            $block['subject'] = t('Random audio');
            $block['content'] = theme('audio_block', $audio);
            break;
          case 2:
            $items = array();
            $settings = audio_get_tag_settings();
            $result = db_query(db_rewrite_sql('SELECT DISTINCT a.tag FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE n.status = 1 ORDER BY a.tag ASC'));
            while ($obj = db_fetch_object($result)) {
              if ($settings[$obj->tag]['browsable']) {
                $items[] = l($obj->tag, 'audio/by/'. $obj->tag);
              }
            }
            $block['subject'] = t('Browse for audio by');
            $block['content'] = theme('item_list', $items);
            break;
        }
        return $block;
      }
  }
}


/**
 * Implementation of hook_settings
 */
function audio_settings() {
  $form['audio_default_title_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Default node title format'),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_default_title_format', '%artist - %title'),
    '#description' => t("The audio node's title can use the file's metadata as variables. This will be used as the default title for all new audio nodes. The following values can be used: ") .'%'. implode(' %', audio_get_tags_allowed()),
  );
  $form['audio_teaser_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Node teaser format'),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_teaser_format', '%player %filelength'),
    '#description' => t("Specify a teaser format for all audio nodes. In addition to the tags allowed in the title, the following variables are also available: "). '%filelength %fileformat %player',
  );
  $form['audio_default_downloadable'] = array(
    '#type' => 'checkbox',
    '#title' => t("Downloadable by default"),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_default_downloadable', 1),
    '#description' => t('Check this to make downloadable the default setting for new audio nodes. You should be aware that even when audio is not marked as downloadable, clever users can still download it, this just makes the work harder. '),
  );

  return $form;
}

/**
 * The ID3 tag settings page.
 */
function audio_admin_settings_metadata() {
  $settings = audio_get_tag_settings();
  $form['audio_tag_settings'] = array('#tree' => TRUE);
  foreach ($settings as $tag => $setting) {
    $form['audio_tag_settings'][$tag]['name'] = array(
      '#type' => 'item', '#value' => $tag);
    $form['audio_tag_settings'][$tag]['autocomplete'] = array(
      '#type' => 'checkbox', '#default_value' => $setting['autocomplete'],
      '#return_value' => 1);
    $form['audio_tag_settings'][$tag]['required'] = array(
      '#type' => 'checkbox', '#default_value' => $setting['required'],
      '#return_value' => 1);
    $form['audio_tag_settings'][$tag]['hidden'] = array(
      '#type' => 'checkbox', '#default_value' => $setting['hidden'],
      '#return_value' => 1);
    $form['audio_tag_settings'][$tag]['browsable'] = array(
      '#type' => 'checkbox', '#default_value' => $setting['browsable'],
      '#return_value' => 1);
    $form['audio_tag_settings'][$tag]['writetofile'] = array(
      '#type' => 'checkbox', '#default_value' => $setting['writetofile'],
      '#return_value' => 1);
    $form['audio_tag_settings'][$tag]['weight'] = array(
      '#type' => 'weight', '#default_value' => $setting['weight'],);
  }
  $deleteOptions = array();
  foreach($settings as $tag => $setting) {
    $deleteOptions[$tag] = '';
  }
  $form['delete'] = array(
    '#type' => 'checkboxes',
    '#options' => $deleteOptions,
  );

  // row for a new tag
  $form['audio_tag_settings']['new']['name'] = array(
    '#type' => 'textfield', '#size' => 15, '#maxlength' => 45);
  $form['audio_tag_settings']['new']['autocomplete'] = array(
    '#type' => 'checkbox', '#default_value' => TRUE, '#return_value' => 1);
  $form['audio_tag_settings']['new']['required'] = array(
    '#type' => 'checkbox', '#default_value' => FALSE, '#return_value' => 1);
  $form['audio_tag_settings']['new']['hidden'] = array(
    '#type' => 'checkbox', '#default_value' => FALSE, '#return_value' => 1);
  $form['audio_tag_settings']['new']['browsable'] = array(
    '#type' => 'checkbox', '#default_value' => TRUE, '#return_value' => 1);
  $form['audio_tag_settings']['new']['writetofile'] = array(
    '#type' => 'checkbox', '#default_value' => FALSE, '#return_value' => 1);
  $form['audio_tag_settings']['new']['weight'] = array(
    '#type' => 'weight', '#default_value' => 0);

  return system_settings_form('audio_admin_settings_metadata', $form);
}

/**
 * Save the ID3 tag settings, we can't use system_settings_form_submit() as the
 * form callback because it wouldn't call theme_audio_settings().
 */
function audio_admin_settings_metadata_submit($form_id, $form_values) {
  $op = isset($_POST['op']) ? $_POST['op'] : '';

  if ($op == t('Reset to defaults')) {
    variable_del('audio_tag_settings');
    drupal_set_message(t('The configuration options have been reset to their default values.'));
  }
  else {
    // remove any deleted tags
    foreach ($form_values['delete'] as $field) {
      if ($field) {
        unset($form_values['audio_tag_settings'][$field]);
      }
    }
    // if there's a new tag, add it in
    if ($form_values['audio_tag_settings']['new']['name']) {
      $name = $form_values['audio_tag_settings']['new']['name'];
      $form_values['audio_tag_settings'][$name] = $form_values['audio_tag_settings']['new'];
    }
    unset($form_values['audio_tag_settings']['new']);

    // sort by the weight and then by name of the tag. i'm sure there's a
    // better way to do this...
    foreach ($form_values['audio_tag_settings'] as $tag => $settings) {
      $weights[$tag] = $settings['weight'];
      $names[$tag] = $tag;
    }
    array_multisort($weights, SORT_ASC, SORT_NUMERIC, $names, SORT_ASC, SORT_STRING);
    $audio_tag_settings = array();
    foreach ($names as $tag) {
      $audio_tag_settings[$tag] = $form_values['audio_tag_settings'][$tag];
    }

    // and save it
    variable_set('audio_tag_settings', $audio_tag_settings);

    drupal_set_message(t('The configuration options have been saved.'));
  }
}

/**
 * Get an array of the allowed tags.
 *
 * @return
 *   array of allowed tags.
 */
function audio_get_tags_allowed() {
  return array_keys(audio_get_tag_settings());
}
/**
 * Get an array of the tags and their settings.
 * @return array of allowed tags.
 */
function audio_get_tag_settings() {
  $defaults = array(
    'artist' => array('autocomplete' => 1, 'required' => 1, 'hidden' => 0,
      'writetofile' => 1, 'browsable' => 1, 'weight' => -2),
    'title'  => array('autocomplete' => 1, 'required' => 1, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => -2),
    'album'  => array('autocomplete' => 1, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => -1),
    'track'  => array('autocomplete' => 0, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 0, 'weight' => -1),
    'genre'  => array('autocomplete' => 1, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => 0),
    'year'   => array('autocomplete' => 0, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => 1),
  );
  return variable_get('audio_tag_settings', $defaults);
}

/**
 * Retrieve autocomplete suggestions for existing audio metadata tags.
 *
 * @param $tag
 *   tag listed in audio_get_tag_settings() where autocomplete is true.
 * @param $value
 *   partial tag value to try to find in the database.
 */
function audio_autocomplete($tag = '', $value = '') {
  $matches = array();
  $tags = audio_get_tag_settings();
  if (isset($tags[$tag]) && $tags[$tag]['autocomplete']) {
    $result = db_query_range("SELECT DISTINCT a.value FROM {audio_metadata} a WHERE a.tag = '%s' && LOWER(a.value) LIKE LOWER('%s%%') ORDER BY a.value", $tag, $value, 0, 10);
    while ($tag = db_fetch_object($result)) {
      $matches[$tag->value] = check_plain($tag->value);
    }
  }
  print drupal_to_js($matches);
  exit();
}

/**
 * Get the audio files directory.
 *
 * @return
 *   string path to the audio directory
 */
function audio_get_directory() {
  // we have to make sure the files directory exists first...
  $dir = file_directory_path();
  file_check_directory($dir, FILE_CREATE_DIRECTORY, 'made up element name');
  // ...then that our audio sub-directory exists
  $dir .= '/audio';
  file_check_directory($dir, FILE_CREATE_DIRECTORY, 'made up element name');

  return $dir;
}

/**
 * Menu callback; displays a Drupal page containing recent audio entries
 */
function audio_page($a = NULL, $b = NULL) {
  // check these two parameters for backwards compatibility with old URL formats.
  if (is_numeric($a)) {
    // $a is a user ID
    if ($b == 'feed') {
      drupal_goto('audio/feed/user/'. $a);
    }
    else {
      drupal_goto('audio/user/'. $a);
    }
  }

  return audio_page_latest();
}

/**
 * Provide a way to browse the audio by metadata.
 *
 * @param $tag
 *   ID3 tag name
 * @param $value
 *   Value of the tag. It'll be "cleaned" of non-alphanumeric values characters
 *   comparing it
 */
function audio_page_browse_by($tag = NULL, $value = NULL) {
  $breadcrumb = array(
    l(t('Home'), NULL),
    l(t('audio'), 'audio'),
  );

  if (isset($tag)) {
    $breadcrumb[] = l(t('browse by'), 'audio/by');

    if (isset($value)) {
      drupal_set_title(t("audio by %tag '%value'", array('%tag' => $tag, '%value' => trim(str_replace('_', ' ', $value)))));

      $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, a.tag, a.value FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE a.tag = '%s' AND a.clean = '%s' AND n.status = 1 ORDER BY n.created ASC"), $tag, audio_clean_tag($value));
      $breadcrumb[] = l(t('%tag', array('%tag' => $tag)), 'audio/by/'. $tag);

      $output = '';
      while ($obj = db_fetch_object($result)) {
        if ($node = node_load($obj->nid)) {
          $output .= node_view($node, TRUE);
        }
      }
    }
    else {
      drupal_set_title(t("audio by %tag", array('%tag' => $tag)));

      $result = db_query(db_rewrite_sql("SELECT a.value, a.clean, COUNT(a.clean) AS count FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE a.tag = '%s' AND n.status = 1 GROUP BY a.clean ORDER BY a.value ASC"), $tag);
      while ($obj = db_fetch_object($result)) {
        $items[] = l($obj->value, "audio/by/{$tag}/{$obj->clean}") ." ({$obj->count})";
      }
      $output = theme('item_list', $items);
    }
  }
  else {
    drupal_set_title(t("Browse for audio by..."));

    $settings = audio_get_tag_settings();
    $result = db_query(db_rewrite_sql('SELECT DISTINCT a.tag FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE n.status = 1 ORDER BY a.tag ASC'));
    while ($obj = db_fetch_object($result)) {
      if ($settings[$obj->tag]['browsable']) {
        $items[] = l($obj->tag, 'audio/by/'. $obj->tag);
      }
    }
    $output = theme('item_list', $items);
  }

  drupal_set_breadcrumb($breadcrumb);

  return $output;
}

/**
 * Displays an RSS feed containing recent blog entries of a given user.
 */
function audio_feed_user($uid = 0) {
  global $user;

  if ($uid) {
    $account = user_load(array('uid' => $uid, 'status' => 1));
  }
  else {
    $account = $user;
  }

  $result = db_query_range(db_rewrite_sql("SELECT n.nid FROM {node} n INNER JOIN {users} u ON n.uid = u.uid WHERE n.type = 'audio' AND u.uid = %d AND n.status = 1 ORDER BY n.created DESC"), $uid, 0, 15);
  $channel['title'] = t("%username's audio files", array('%username' => $account->name));
  $channel['link'] = url("audio/$uid", NULL, NULL, TRUE);
  //$channel['description'] = t('Audio files posted by %username', array('%username' => $account->name));
  node_feed($result, $channel);
}

/**
 * Displays an RSS feed containing recent audio feeds of all users.
 */
function audio_feed_latest() {
  $sitename = variable_get('site_name', 'drupal');
  $result = db_query_range(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = 'audio' AND n.status = 1 ORDER BY n.created DESC"), 0, 15);
  $channel['title'] = t("%sitename audio files", array('%sitename' => $sitename));
  $channel['link'] = url('audio', NULL, NULL, TRUE);
  //$channel['description'] = t("%sitename's most recently posted audio.", array('%sitename' => $sitename));
  node_feed($result, $channel);
}

/**
 * Displays a Drupal page containing recent audio entries of a given user.
 */
function audio_page_user($uid = NULL) {
  global $user;

  if (is_null($uid)) {
    $uid = $user->uid;
  }
  $account = user_load(array((is_numeric($uid) ? 'uid' : 'name') => $uid, 'status' => 1));

  if ($account->uid) {
    $title = t("%name's audio files", array('%name' => $account->name));
    drupal_set_title($title);

    $attributes = array(
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'title' => t('RSS - %title', array('%title' => $title)),
      'href' => url("audio/feed/user/{$account->uid}"),
    );
    drupal_add_link($attributes);

    $output = '';
    if ($account->uid == $user->uid) {
      if (user_access('create audio')) {
        $items[] = l(t('Add a new audio file.'), 'node/add/audio');
      }
      else {
        $items[] = t('You are not allowed to add audio files.');
      }
      $output = theme('item_list', $items);
    }

    $result = pager_query(db_rewrite_sql("SELECT n.nid, n.sticky, n.created FROM {node} n WHERE n.type = 'audio' AND n.uid = %d AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC"), variable_get('default_nodes_main', 10), 0, NULL, $account->uid);
    while ($node = db_fetch_object($result)) {
      $output .= node_view(node_load($node->nid), 1);
    }
    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));
    $output .= theme('xml_icon', url("audio/feed/user/$account->uid"));

    return $output;
  }
  else {
    drupal_not_found();
  }
}



/**
 * Fetch a random N audio files.
 */
function audio_get_random($count = 1) {
  $result = db_query_range(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type='audio' AND n.status=1 ORDER BY RAND()"), 0, $count);
  $output = array();
  while ($nid = db_fetch_object($result)) {
    $output[] = node_load($nid->nid);
  }
  return $output;
}

/**
 * Fetch the latest N audio files.
 */
function audio_get_latest($count = 1) {
  $result = db_query_range(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type='audio' AND n.status=1 ORDER BY changed DESC"), 0, $count);
  $output = array();
  while ($nid = db_fetch_object($result)) {
    $output[] = node_load($nid->nid);
  }
  return $output;
}

/**
 * Build HTML to play an audio node.
 *
 * @return
 *   HTML to play the audio track.
 */
function audio_get_player($node) {
  // if we've got a URL, setup a player
  if (_audio_allow_play($node)) {
    // try to find one that's type specific...
    $format = $node->audio_fileinfo['fileformat'];
    if (!$player = theme('audio_'. $format .'_player', $node)) {
      // ...if that doesn't work out, use the generic one
      $player = theme('audio_player', $node);
    }
    return $player;
  }
  return NULL;
}

/**
 * Displays a Drupal page containing recent audio entries of all users.
 */
function audio_page_latest() {
  $output = '';

  $result = pager_query(db_rewrite_sql("SELECT n.nid, n.created FROM {node} n WHERE n.type = 'audio' AND n.status = 1 ORDER BY n.created DESC"), variable_get('default_nodes_main', 10));

  while ($node = db_fetch_object($result)) {
    $output .= node_view(node_load($node->nid), 1);
  }
  $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));
  $output .= theme('xml_icon', url('audio/feed'));

  $attributes = array(
    'rel' => 'alternate',
    'type' => 'application/rss+xml',
    'title' => t('RSS - Latest audio files'),
    'href' => url("audio/feed"),
  );
  drupal_add_link($attributes);

  return $output;
}

/**
 * Take a tag and force it to be a-z 0-9 _ -
 * @param $string
 *   ID3 tag value
 * @return
 *   cleaned up tag value for URL or database
 */
function audio_clean_tag($string) {
  // if we've got characters besides 0-9 A-Z a-z hyphen or underscore, replace them
  if (preg_match('/[^-\w]/', $string)) {
    // remove accents
    $string = strtr($string, '', 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy');
    // convert to equivalent chars
    $string = strtr($string, array('' => 'TH', '' => 'th', '' => 'DH', '' => 'dh', '' => 'ss', '' => 'OE', '' => 'oe', '' => 'AE', '' => 'ae', '' => 'u'));
    // remove anything else that's not alphanumeric and replace it with an underscore
    $string = preg_replace('/[^-\w]+/', '_', $string);
  }
  // wack any leading or trailing underscores
  $string = trim($string, '_');
  // finally, make it to lower case
  return strtolower($string);
}


/**
 * Fetches an audio file, allows "shorthand" urls such of the form:
 * audio/view/$nid (e.g. audio/download/25/ or audio/download/14)
 */
function audio_download($nid = false) {
  if ($node = node_load($nid)) {
    if (_audio_allow_download($node)) {
      // increment the play count
      db_query('UPDATE {audio} SET download_count = download_count + 1 WHERE vid = %d', $node->vid);

      // downloading counts as "viewing" the node
      node_tag_new($node->nid);

      // notify other modules
      audio_invoke_audioapi('download', $node);

      $headers = array(
        'Content-Type: '. $node->audio_file->filemime,
        'Content-Length: '. $node->audio_file->filesize,
        'Content-Disposition: attachment; filename="'. $node->audio_file->origname .'"',
      );
      file_transfer($node->audio_file->filepath, $headers);
    }
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
}

/**
 * Similar to audio_download, but for streaming playback instead of download.
 */
function audio_play($nid = false) {
  if ($node = node_load($nid)) {
    if (_audio_allow_play($node)) {
      // increment the play count
      db_query('UPDATE {audio} SET play_count = play_count + 1 WHERE vid = %d', $node->vid);

      // playing counts as "viewing" the node
      node_tag_new($node->nid);

      // notify other modules
      audio_invoke_audioapi('play', $node);

      $headers = array(
        "Pragma: public", // required
        "Expires: 0",
        "Cache-Control: must-revalidate, post-check=0, pre-check=0, private",
        'Content-Type: '. $node->audio_file->filemime,
        'Content-Length: '. $node->audio_file->filesize,
        'Content-Disposition: inline;',
        'Content-Transfer-Encoding: binary',
      );
      // required for IE, otherwise Content-disposition is ignored
      ini_set('zlib.output_compression', 'Off');
      file_transfer($node->audio_file->filepath, $headers);
    }
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
}


/**
 * Function for other modules to use to create a audio node from a file. Once
 * you've created it you can make any changes and then save it using
 * node_save().
 *
 * @param $filepath
 *   full path to an audio file. be aware that the file will be moved into
 *   drupal's directory.
 * @param $title_format
 *   a t() formatting string for generating the node's title. you can use any
 *   value in the node's audio_tags array as variable. if nothing is provided
 *   the default title format will be used.
 * @param $tags
 *   an, optional, array of metadata to add to the node. these will be
 *   available to the $title_format.
 * @return
 *   a node or FALSE on error
 */
function audio_api_insert($filepath, $title_format = null, $tags = array()) {
  global $user;

  //check for user permission...
  if (!audio_access('create')) {
    drupal_access_denied();
  }

  // make that a proper path
  $filepath = realpath($filepath);

  // start building a node
  $node = new stdClass();
  $node->type = 'audio';
  $node->uid = $user->uid;

  // set the node's defaults... (copied this from node and comment.module)
  $node_options = variable_get('node_options_'. $node->type, array('status', 'promote'));
  $node->status = in_array('status', $node_options);
  $node->moderate = in_array('moderate', $node_options);
  $node->promote = in_array('promote', $node_options);
  if (module_exist('comment')) {
    $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);
  }

  // default audio info
  $node->title_format = $title_format;
  $node->audio_tags = array();
  $node->audio_images = array();

  // file object
  $node->audio_file = new stdClass();
  $node->audio_file->newfile = TRUE;
  $node->audio_file->filename = basename($filepath);
  $node->audio_file->filepath = $filepath;
  if (function_exists('mime_content_type')) {
    $node->audio_file->filemime = mime_content_type($filepath);
  }
  else {
    // this may be a bad guess...
    $node->audio_file->filemime = 'audio/mpeg';
  }
  $node->audio_file->filesize = filesize($filepath);

  // fileinfo
  $node->audio_fileinfo = array(
    'downloadable' => variable_get('audio_default_downloadable', 1),
    'play_count' => 0,
    'download_count' => 0,
    'filesize' => $node->audio_file->filesize,
  );

  // allow other modules to modify the node (hopefully reading in tags)
  audio_invoke_audioapi('upload', $node);

  // add the tags (overwriting any that audio_getid3 loaded)
  if ($tags) {
    $node->audio_tags = $tags;
  }

  // ...then save it
  node_submit($node);
  node_save($node);

  return $node;
}

/**
 * Save the node's ID3 tags into the database.
 */
function _audio_save_tags_to_db($node) {
  $allowed_tags = audio_get_tags_allowed();

  // remove any existing cached metadata from audio metadata...
  db_query("DELETE FROM {audio_metadata} WHERE vid=%d", $node->vid);

  // save the new tags
  foreach ($node->audio_tags as $tag => $value) {
    if (in_array($tag, $allowed_tags) && $value) {
      db_query("INSERT INTO {audio_metadata} (vid, tag, value, clean) VALUES (%d, '%s', '%s', '%s')",
        $node->vid, $tag, $value, audio_clean_tag($value));
    }
  }
}

/**
 * Check PHP's post_max_size and upload_max_filesize settings and determine
 * the maximum size of a file upload.
 *
 * @return
 *   an integer number of bytes
 */
function audio_get_max_upload_size() {
  $limits = array();
  foreach (array('upload_max_filesize', 'post_max_size') as $setting) {
    // the post_max_size and upload_max_filesize settings could be a string
    // ('2m', '1G') or an integer (2097152 or 1073741824).
    $val = ini_get($setting);
    if (!is_numeric($val)) {
      // separate the numeric and alpha parts, then get to multiplying
      $val = trim($val);
      $last = strtolower($val{strlen($val)-1});
      switch($last) {
        case 'g':
          $val *= 1024;
        case 'm':
          $val *= 1024;
        case 'k':
          $val *= 1024;
      }
    }
    $limits[] = $val;
  }
  // the smallest value will be the limiting factor so retun it.
  return min($limits);
}
